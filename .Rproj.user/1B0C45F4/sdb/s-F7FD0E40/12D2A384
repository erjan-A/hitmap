{
    "collab_server" : "",
    "contents" : "require(ggplot2)\nrequire(rgdal)\nrequire(scales)\nrequire(dplyr)\nrequire(maptools)\nrequire(sp)\nrequire(maps)\nrequire(raster)\nrequire(leaflet)\nrequire(shiny)\nrequire(fields)\nsource(\"API.R\")\n\nshinyServer(function(input, output, session) {\n\n  #Load San Francisco Census Blocks data\n  blocks <- shapefile(\"data/tl_2010_06075_tabblock10edited/tl_2010_06075_tabblock10.shp\")\n  # blocks <- shapefile(\"data/cb_2014_06_tract_500k/cb_2014_06_tract_500k.shp\")\n  blocks <- spTransform(x=blocks, CRSobj=CRS(\"+proj=longlat +datum=WGS84\"))\n  names(blocks@data) <- tolower(names(blocks@data))\n  \n  \n  #Load San Francisco 2015 crime data\n  crime_data <- read.csv(\"data/SFPD_Incidents_-_Previous_Year__2015_.csv\", stringsAsFactors = FALSE, header = TRUE)\n  crime_data$Category <- tolower(crime_data$Category)\n  \n  #Load Categroy Scoring data\n  category_score <- read.csv(\"data/category_score.csv\", stringsAsFactors = FALSE, header = TRUE)\n  category_score$Category <- tolower(category_score$Category)\n  \n  #Load SF attractions data\n  attractions <- read.csv(\"data/sf-attractions.csv\", stringsAsFactors = FALSE, header = TRUE)\n  \n  \n  ###########################################################################\n  \n  \n  # Cleaning and Keeping only complete cases\n  # Loading SF 2015 and 2016 crime data -> remove unnecessary columns -> merge -> load category table -> assign (match) weights to each crime based on category\n  crime_data <- crime_data[complete.cases(crime_data), ]\n  \n  # Assign category score to each crime\n  cat <- match(x=crime_data$Category, table=category_score$Category)\n  crime_data$Score <- category_score$Score[cat]\n  \n  #Remove unncessary columns and turn crime_data in to data frame\n  df.crime_data <- data.frame(category=crime_data$Category, pdid=crime_data$PdId, score=crime_data$Score, latitude=crime_data$Y, longitude=crime_data$X)\n  \n  \n  ###########################################################################\n  \n  \n  #Convert crime data to a spatial points object\n  df.crime_data <- SpatialPointsDataFrame(coords=df.crime_data[, c(\"longitude\", \"latitude\")], data=df.crime_data[, c(\"category\", \"pdid\", \"score\")], proj4string=CRS(\"+proj=longlat +datum=WGS84\"))\n  \n  #Spatial overlay to identify census polygon in which each crime point falls\n  #The Result `crime_blocks` is a dataframe with the block data for each point\n  crime_blocks <- over(x=df.crime_data, y=blocks)\n  \n  #Add block data to each crime \n  df.crime_data@data <- data.frame(df.crime_data@data, crime_blocks)\n  \n  #Aggregate crimes by block \n  agg_crimeblocks <- aggregate(cbind(df.crime_data@data$score)~geoid10, data = df.crime_data, FUN = sum)\n  \n  #Format score into ranking\n  agg_crimeblocks$V1 <- dense_rank(agg_crimeblocks$V1)\n  \n  #Add number of crimes to blocks object\n  m <- match(x=blocks@data$geoid10, table=agg_crimeblocks$geoid10)\n  blocks@data$score <- agg_crimeblocks$V1[m]\n  \n  maxScore <- max(agg_crimeblocks$V1)\n  \n  ###########################################################################\n  \n  ## Plotting an interactive map with leaflet ##\n  \n  # Copying blocks df\n  df.blocks <- blocks\n  \n  # Cleaning blocks data: replacing NA (crime rate) with 0 \n  df.blocks@data$score[is.na(df.blocks@data$score)] <- 0\n  \n  \n  #Load SF attractions data\n  attractions <- read.csv(\"data/sf-attractions.csv\", stringsAsFactors = FALSE, header = TRUE)\n  \n  # Format CRS of data frame\n  att <- subset(attractions, select = c(longitude, latitude))\n  coordinates(att) <- c(\"longitude\", \"latitude\")\n  proj4string(att) <- CRS(\"+proj=longlat + ellps=WGS84\")\n  att <- spTransform(att, CRS(proj4string(df.blocks)))\n  \n  # Get rid of bad attractions outside SF\n  att <- att[df.blocks,]\n  att <- as.data.frame(att)\n  \n  set.seed(12345)\n  \n  # Using kmeans to get the centroids of attraction locations\n  att.8means <- kmeans(att, 8, iter.max = 10)\n  \n  att_cluster_centers <- att.8means$centers\n  att_cluster_sizes <- att.8means$size\n  \n  # Get a table of centroids and their corresponding sizes\n  att_cluster_centers <- cbind(att_cluster_centers, att_cluster_sizes) \n  \n  ###########################################################################\n  \n  ## Plotting an interactive map with leaflet ##\n  \n  \n  # Cleaning blocks data: replacing NA (crime rate) with 0 \n  df.blocks@data$score[is.na(df.blocks@data$score)] <- 0\n  \n  # Legend\n  ATgreen <- rgb(46/255, 204/255, 113/255, 1)\n  ATyellow <- rgb(241/255, 196/255, 14/255, 1)\n  ATred <- rgb(231/255, 76/255, 60/255, 1)\n  \n  polpopup <- paste0(\"Hitmap score: \", paste(round(100-(df.blocks$score/maxScore)*100,digits=2),\"%\",sep=\"\"))\n  attractionspopup <- paste0(\"Attraction: \", attractions$name, \"<br>\", \"Address: \", attractions$address.street, \"<br>\", \"<a href=\", attractions$profile, \">\", \"Link\", \"</a>\" )\n  pal <- colorNumeric(\n    palette = c(ATgreen, ATyellow, ATred),\n    domain = df.blocks$score)\n\n\n  # Get input values\n  inputs <- reactive({\n    as.character(inputs$with)\n  })\n  \n  # Draw map\n  output$map <- renderLeaflet({\n    leaflet(data = c(attractions)) %>% setView(lng = -122.447902, lat = 37.761886, zoom = 12) %>%\n      addTiles() %>%\n      addPolygons(data = df.blocks, \n                  fillColor = ~pal(score), \n                  color = NA,\n                  fillOpacity = 0.7, \n                  weight = 1, \n                  smoothFactor = 0.5,\n                  popup = polpopup) %>%\n      addLegend(\n        colors = c('#e74c3c', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#59d285'), \n        labels = c(\"<span style='font-size:11px'>Less safe</span>\",\"\",\"\",\"\",\"\",\"<span style='font-size:11px'>Safer</span>\"),\n        values = df.blocks$score, \n        position = \"bottomright\", \n        title = \"Crime Risk\",\n        opacity = 0.6) %>%\n#      addMarkers(hotels_sample$lon, hotels_sample$lat, popup = markerpopup) %>%\n      addCircleMarkers(attractions$longitude, attractions$latitude, \n                       popup = attractionspopup,\n                       radius = 5,\n                       color = \"#9b59b6\",\n                       stroke = FALSE, fillOpacity = 0.5,\n                       group = \"Attractions\") %>%\n      addLayersControl(\n        overlayGroups = c(\"Attractions\"),\n        options = layersControlOptions(collapsed = FALSE)\n      )\n  })\n  \n  #Search button event listener\n  observeEvent(input$search, {\n    \n    #Clear existing data\n    leafletProxy(\"map\", session) %>% clearGroup(group=\"hotels\")\n    output$results <- renderPrint({\n      invisible()\n    })\n    \n    output$results_count <- renderPrint({\n      invisible()\n    })\n    \n    output$hotels_table <- renderPrint({\n      invisible()\n    })\n    \n    #Getting hotels using API\n    hotel_r <- HitMap_hotels(input$dateRange[1],input$dateRange[2])\n    hotel_r <- subset(hotel_r, select = -c(results.contacts, results.amenities, results.images, results.rooms, results.awards, results.marketing_text))\n    \n    #Spatial overlay to identify census polygon in which each hotel falls\n    df.hotel_r <- SpatialPointsDataFrame(coords=hotel_r[, c(\"results.location.longitude\", \"results.location.latitude\")], data=hotel_r[, c(\"results.property_name\", \"results.address.line1\", \"results.address.postal_code\", \"results.total_price.amount\",\"results.min_daily_rate.amount\", \"results._links.more_rooms_at_this_hotel.href\")], proj4string=CRS(\"+proj=longlat +datum=WGS84\"))\n    \n    #The Result `crime_blocks` is a dataframe with the block data for each point\n    hotel_blocks <- over(x=df.hotel_r, y=df.blocks)\n    \n    #Add block data to each hotel\n    df.hotel_r@data <- data.frame(df.hotel_r@data, score=round(100-(hotel_blocks$score/maxScore)*100,digits=2))\n    \n    hotel_r_by_scores <- df.hotel_r@data\n    hotel_r_by_scores <- cbind(hotel_r_by_scores, df.hotel_r@coords[,\"results.location.longitude\"])\n    hotel_r_by_scores <- cbind(hotel_r_by_scores, df.hotel_r@coords[,\"results.location.latitude\"])\n    \n    hotel_r_by_scores <- hotel_r_by_scores[,c(8,9, 1:7)]\n    \n    # Calculate the distances from hotels to each of the attraction cluster centroids\n    hotel_att_distance <- 1/rdist.earth(hotel_r_by_scores, as.data.frame(att_cluster_centers), miles = FALSE)\n    \n    # Calculate distance * size for each hotel/centroid\n    hotel_att_distance_sizes <- hotel_att_distance*att_cluster_sizes\n    ranks <- dense_rank(hotel_att_distance_sizes)\n    hotel_att_distance_sizes_rank <- t(as.data.frame(split(ranks, 1:as.integer(count(hotel_r_by_scores)))))\n    hotel_att_distance_rank <- as.data.frame(rowSums(hotel_att_distance_sizes_rank))\n    hotel_att_distance_rank <- 100*(hotel_att_distance_rank/max(hotel_att_distance_rank))\n    \n    hotel_r_by_scores <- cbind(hotel_r_by_scores, hotel_att_distance_rank)\n    colnames(hotel_r_by_scores)[10] = \"att_score\"\n    hotel_r_by_scores <- cbind(hotel_r_by_scores, (.6*hotel_r_by_scores$score + .4*hotel_r_by_scores$att_score))\n    colnames(hotel_r_by_scores)[11] = \"hitmap_score\"\n    hotel_r_by_scores <- hotel_r_by_scores[order(-hotel_r_by_scores$hitmap_score),]\n    hotel_r_by_scores$hitmap_score_5 <- round(hotel_r_by_scores$hitmap_score*5/100, digits = 2)\n    total_hotels_number <- as.integer(count(hotel_r_by_scores))\n    \n    if (input$results_number != \"all\") {\n      hotel_r_by_scores <- hotel_r_by_scores[1:as.character(input$results_number),]\n    }\n\n    \n    #Plotting hotel on the map\n    markerpopup <- paste0(\"Hotel: \", hotel_r_by_scores$results.property_name, \"<br>\", \"Total Price: $\", hotel_r_by_scores$results.total_price.amount, \"<br>\", \"Hitmap Score: \", hotel_r_by_scores$hitmap_score_5,\"/ 5\")\n    leafletProxy(\"map\", session) %>% addMarkers(hotel_r_by_scores[,1], hotel_r_by_scores[,2], popup = markerpopup, group=\"hotels\")\n    \n    #Display number of hotels\n    output$results_count <- renderUI({\n      result_count <- as.character(as.integer(count(hotel_r_by_scores)))\n      div(class=\"result_count_p\", tags$strong(total_hotels_number), tags$span(\" hotels found\"), tags$span(class=\"right-span\", \"Sorted by Hitmap score\"))\n    })\n    \n    \n    #Display a table of hotels\n    output$hotels_table <- renderUI({\n      lapply(1:as.integer(count(hotel_r_by_scores)), function(i) {\n        div(class=\"thumbnail card-1\",\n            div(class=\"caption\",\n                div(class=\"left\",\n                  tags$h4(hotel_r_by_scores$results.property_name[i]),\n                  tags$p(class=\"address\", hotel_r_by_scores$results.address.line1[i], hotel_r_by_scores$results.address.postal_code[i]),\n                  tags$p(class=\"reviews\", \"Hitmap score: \",  hotel_r_by_scores$hitmap_score_5[i] , \"/ 5\")\n                ),\n                div(class=\"right\",\n                    tags$p(class=\"price\", \"$\", hotel_r_by_scores$results.total_price.amount[i]),\n                    tags$p(class=\"link\", tags$a(href=hotel_r_by_scores$results._links.more_rooms_at_this_hotel.href[i], \"Book\"))\n                    )\n            )\n        )\n      })\n    })\n    \n    #output$results <- renderTable(hotel_r_by_scores)\n    \n  })\n  \n  #Clear button event listner: clear hotels on map and table\n  observeEvent(input$clear, {\n    leafletProxy(\"map\", session) %>% clearGroup(group=\"hotels\")\n    output$results <- renderPrint({\n      invisible()\n    })\n    output$results_count <- renderPrint({\n      invisible()\n    })\n    \n    output$hotels_table <- renderPrint({\n      invisible()\n    })\n  })\n  \n})",
    "created" : 1461791223277.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "286367544",
    "id" : "12D2A384",
    "lastKnownWriteTime" : 1462475348,
    "last_content_update" : 1462475348997,
    "path" : "~/Downloads/hitmap/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}